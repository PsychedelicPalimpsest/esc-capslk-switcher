plugins {
	id 'fabric-loom' version "${loom_version}"
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	// Repositories
}

// Helper functions
def version_to_comparable(String version) {
    def parts = version.split('\\.').collect { it.toInteger() }
    while (parts.size() < 3) {
        parts.add(0)
    }
    return parts[0] * 1000000 + parts[1] * 1000 + parts[2]
}

def satisfies(String version, List<String> constraint) {
    def nv = version_to_comparable(version)
    return nv >= version_to_comparable(constraint[0]) &&
            nv <= version_to_comparable(constraint[1])
}

// Define versioned source sets
def versionedSourceSets = [
        [dir: "pre_1_21_9", constraint: ["1.15", "1.21.8"]],
        [dir: "newest", constraint: ["1.21.9", "9.9.9"]]
]

// Find the active specification based on the current Minecraft version
def activeSpec = versionedSourceSets.find {
    satisfies(project.minecraft_version, it.constraint)
}

if (!activeSpec) {
    throw new GradleException("No matching source set found for Minecraft version ${project.minecraft_version}")
}

def activeMixinDir = activeSpec.dir
def allMixinDirs = versionedSourceSets.collect { it.dir }
def inactiveMixinDirs = allMixinDirs - [activeMixinDir]

// Configure source sets to exclude inactive directories from compilation
sourceSets {
    main {
        java {
            inactiveMixinDirs.each { dir ->
                // Exclude any directory matching the inactive names
                exclude "**/$dir/**"
            }
        }
    }
}

dependencies {
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings loom.officialMojangMappings()
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
}

tasks.withType(JavaCompile).configureEach {
	it.options.release = 21
}

java {
	withSourcesJar()
	sourceCompatibility = JavaVersion.VERSION_21
	targetCompatibility = JavaVersion.VERSION_21
}

jar {
	inputs.property "archivesName", project.base.archivesName
	from("LICENSE") {
		rename { "${it}_${inputs.properties.archivesName}"}
	}
}

processResources {
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "mixin_version", activeMixinDir

    filesMatching("fabric.mod.json") {
        expand(
                "version": project.version,
                "minecraft_version": project.minecraft_version
        )
    }

    filesMatching("capslock-fix.mixins.json") {
        expand "mixins": activeMixinDir
    }
}

publishing {
	publications {
		create("mavenJava", MavenPublication) {
			artifactId = project.archives_base_name
			from components.java
		}
	}
	repositories {
		// Publishing repositories
	}
}

def targetVersions =[
    "1.21.11",
    "1.21.10",
    "1.21.9",
    "1.21.8",
    "1.21.7",
    "1.21.6",
    "1.21.5",
    "1.21.4",
    "1.21.3",
    "1.21.2",
    "1.21.1",
    "1.21",
    "1.20.6",
    "1.20.5",
    "1.20.4",
    "1.20.3",
    "1.20.2",
    "1.20.1",
    "1.20",
    "1.19.4",
    "1.19.3",
    "1.19.2",
    "1.19.1",
    "1.19",
    "1.18.2",
    "1.18.1",
    "1.18",
    "1.17.1",
    "1.17",
    "1.16.5",
    "1.16.4",
    "1.16.3",
    "1.16.2",
    "1.16.1",
    "1.16",
]
def versionTaskNames = []

targetVersions.each { mcVersion ->
    def taskName = "buildFor_${mcVersion.replace('.', '_')}"
    versionTaskNames.add(taskName)

    tasks.register(taskName, GradleBuild) {
        group = "build"
        description = "Builds the mod for Minecraft ${mcVersion}."

        // Propagate existing project properties to the sub-build
        gradle.startParameter.projectProperties.each { p ->
            if (p.key != "minecraft_version") {
                startParameter.projectProperties.put(p.key, p.value)
            }
        }
        // Set the specific minecraft_version for this sub-build
        startParameter.projectProperties.put("minecraft_version", mcVersion)
        // Define the tasks to run for the sub-build
        tasks = ['clean', 'assemble']

        // After the sub-build completes, copy and rename the artifact
        doLast {
            copy {
                from(layout.buildDirectory.file("libs/${project.archives_base_name}-${project.version}.jar"))
                into(layout.projectDirectory.dir("outputs"))
                rename { _ -> "${project.archives_base_name}-${mcVersion}.jar" }
            }
        }
    }
    tasks.getByName(taskName).mustRunAfter(clean)
}